# `.zshrc' is sourced in interactive shells. It should contain commands to set up aliases, functions, options, key bindings, etc.

# for profiling a slow zsh:
# zmodload zsh/zprof
# then when you get the prompt type: zprof

#[ -z "$TMUX"  ] && { tmux attach || exec tmux new-session && exit;}

source ~/.profile

fpath=($fpath ~/git/zsh-completions)
autoload -U compinit && compinit -u
autoload -U colors && colors
autoload -U bashcompinit && bashcompinit
autoload -U zrecompile

zstyle ':completion:*' use-cache on
zstyle ':completion:*' menu select
zstyle ':completion:*' cache-path ~/.zsh/cache
zstyle ':completion:*' completer _complete _match _approximate
zstyle ':completion:*:match:*' original only
zstyle ':completion:*:approximate:*' max-errors 1 numeric
zstyle ':completion:*' squeeze-slashes true
zstyle ':completion:*:*:kill:*' menu yes select
zstyle ':completion:*:kill:*'   force-list always

setopt prompt_subst \
       auto_cd \
       complete_aliases \
       extended_glob \
       incappendhistory \
       extended_history

HISTFILE="$HOME/.zsh_history"
HISTSIZE=10000000
SAVEHIST=10000000

REPORTTIME=10
WATCH=notme
WATCHFMT='%n %a %l from %m at %T.'

if ! [ "$SLOWPROMPT" = "yes" ]; then
  # source ~/git/zsh-git-prompt/zshrc.sh
  source ~/git/git-prompt/git-prompt.sh
fi

source ~/git/zsh-history-substring-search/zsh-history-substring-search.zsh
which aws_zsh_completer.sh >/dev/null 2>&1 && aws_zsh_completer.sh >/dev/null 2>&1
which direnv >/dev/null 2>&1 && eval "$(direnv hook zsh)"

function check_last_exit_code() {
  local LAST_EXIT_CODE=$?
  if [[ $LAST_EXIT_CODE -ne 0 ]]; then
    local EXIT_CODE_PROMPT='Error code: '
    EXIT_CODE_PROMPT+="%{$fg[red]%}-%{$reset_color%}"
    EXIT_CODE_PROMPT+="%{$fg_bold[red]%}$LAST_EXIT_CODE%{$reset_color%}"
    EXIT_CODE_PROMPT+="%{$fg[red]%}-%{$reset_color%}"
    echo "$EXIT_CODE_PROMPT"
  fi
}


# Nice unicodes for prompt
# ¥
# ▶
# ¤
if [ "$SLOWPROMPT" = "yes" ]; then
  PROMPT='$(check_last_exit_code)
%{$fg[blue]%}%n%{$reset_color%}@%{$fg[red]%}%2m%{$reset_color%}%{$fg[green]%} %~%{$reset_color%}
¤ '
else
  PROMPT='$(check_last_exit_code)
%{$fg[blue]%}%n%{$reset_color%}@%{$fg[red]%}%2m%{$reset_color%}%{$fg[green]%} %~%{$reset_color%} $(git_super_status)
¤ '
fi

# function preexec() {
#   timer=${timer:-$SECONDS}
# }
#
# function precmd() {
#   if [ $timer ]; then
#     timer_show=$(($SECONDS - $timer))
#     export RPROMPT="%F{cyan}${timer_show}s %{$reset_color%}"
#     unset timer
#   fi
# }

autoload -Uz add-zsh-hook

function xterm_title_precmd () {
    print -Pn '\e]2;%n@%m %1~\a'
}

function xterm_title_preexec () {
    print -Pn '\e]2;%n@%m %1~ %# '
    print -n "${(q)1}\a"
}

if [[ "$TERM" == (screen*|xterm*|rxvt*) ]]; then
    add-zsh-hook -Uz precmd xterm_title_precmd
    add-zsh-hook -Uz preexec xterm_title_preexec
fi

bindkey -e
bindkey '^r' history-incremental-search-backward
bindkey "^[[A" history-substring-search-up
bindkey "^[[B" history-substring-search-down

if [ -f $HOME/.localprofile ]; then
  source $HOME/.localprofile
fi

if ! [ "$SLOWPROMPT" = "yes" ]; then
  command -v fortune &>/dev/null && fortune -s
fi
